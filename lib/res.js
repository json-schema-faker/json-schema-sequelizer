'use strict';

const _util = require('sequelize/lib/utils');
const Op = require('sequelize/lib/operators');

const fs = require('fs-extra');
const path = require('path');
const types = require('./types');

const RE_DATA = /^data:(.+?);base64,/;

function _unflattenData(target, props, keys, rfx) {
  Object.keys(props).forEach(key => {
    /* istanbul ignore else */
    if (props[key] !== null) {
      const parts = key.split('.');
      const name = parts.pop();

      let obj = target;

      while (parts.length) {
        const prop = parts.shift();

        /* istanbul ignore else */
        if (!obj[prop]) {
          obj[prop] = {};
        }

        obj = obj[prop];
      }

      obj[name] = props[key];
    }
  });

  keys.forEach(key => {
    /* istanbul ignore else */
    if (rfx[key].hasManyItems && !Array.isArray(target[key])) {
      target[key] = target[key] ? [target[key]] : [];
    }
  });

  return target;
}

function _unflattenObj(pk, names, values, references) {
  const grouped = [];
  const keys = {};

  values.forEach(item => {
    const row = _unflattenData({}, item, names, references);

    /* istanbul ignore else */
    if (typeof keys[row[pk]] === 'undefined') {
      keys[row[pk]] = grouped.length;
      grouped.push(row);
      return;
    }

    const prev = grouped[keys[row[pk]]];

    names.forEach(prop => {
      prev[prop] = prev[prop].concat(row[prop]);
    });
  });

  return grouped;
}

function _cleanData(values, model) {
  Object.keys(model.rawAttributes).forEach(key => {
    const prop = model.rawAttributes[key];

    if ((prop.primaryKey && !values[key]) || (prop._autoGenerated && !prop.references) || (prop.references && !values[key])) {
      delete values[key];
    }

    if (prop.references) {
      const { Model, fieldName } = prop.type.options;

      if (values[Model.name] && values[Model.name][fieldName]) {
        values[key] = values[Model.name][fieldName];
      }
    }
  });

  Object.keys(model.associations).forEach(key => {
    const assoc = model.associations[key];
    const target = (assoc.through && assoc.through.model) || assoc.target;

    if (Array.isArray(values[key])) {
      values[key] = values[key].map(x => _cleanData(x, target));
    } else if (values[key]) {
      values[key] = _cleanData(values[key], target);
    }
  });

  return values;
}

function _fixData(props) {
  const name = path.basename(props.fileName);
  const content = fs.readFileSync(props.filePath).toString('base64');

  return `data:${props.mimeType};name=${name};base64,${content}`;
}

function _fixRefs(refs, values) {
  // FIXME: consider apply this recursively?
  Object.keys(refs).forEach(ref => {
    /* istanbul ignore else */
    if (Array.isArray(values[ref]) && refs[ref] && refs[ref].through) {
      const through = typeof refs[ref].through === 'object'
        ? refs[ref].through.model
        : refs[ref].through;

      values[ref] = values[ref].map(item => {
        const sub = item[through];

        delete item[through];

        sub[refs[ref].model] = item;

        return sub;
      });
    }
  });
}

function _expandData(raw, props, attachments) {
  /* istanbul ignore else */
  if (!props || typeof props !== 'object') {
    return props;
  }

  /* istanbul ignore else */
  if (Array.isArray(props)) {
    // transform the result before finishing the response
    return props.map(x => _expandData(raw, x, attachments));
  }

  /* istanbul ignore else */
  if (props.dataValues) {
    return raw ? props : _expandData(raw, props.dataValues, attachments);
  }

  /* istanbul ignore else */
  if (typeof props.mimeType !== 'undefined'
    && typeof props.fileSize !== 'undefined'
    && typeof props.fileName !== 'undefined'
    && typeof props.filePath !== 'undefined'
    && attachments[0] && typeof props[attachments[0].key] === 'undefined') {
    props[attachments[0].key] = _fixData(props);
    return props;
  }

  Object.keys(props).forEach(key => {
    const value = props[key];

    /* istanbul ignore else */
    if (value && typeof value === 'object') {
      if (typeof value.mimeType !== 'undefined'
        && typeof value.fileSize !== 'undefined'
        && typeof value.fileName !== 'undefined'
        && typeof value.filePath !== 'undefined') {
        props[key] = _fixData(value);
      } else {
        props[key] = _expandData(raw, value, attachments);
      }
    }
  });

  return props;
}

function _saveUploads(Model, payload, attachments, onUploadCallback) {
  const baseDir = attachments.baseDir || process.cwd();
  const schema = Model.options.$schema.properties;
  const tasks = [];

  Object.keys(Model.rawAttributes).forEach(prop => {
    /* istanbul ignore else */
    if (payload[prop]
      && payload[prop].$upload
      && attachments.files[payload[prop].$upload]
    ) {
      const attachment = attachments.files[payload[prop].$upload];
      const metadata = {
        filePath: path.relative(baseDir, attachment.path),
        fileName: attachment.name,
        fileSize: attachment.size,
        fileType: attachment.type,
      };

      if (Model.rawAttributes.filePath
        && Model.rawAttributes.fileName
        && Model.rawAttributes.fileSize
        && Model.rawAttributes.fileType
      ) {
        delete payload[prop];
        Object.assign(payload, metadata);
        return;
      }

      if (schema[prop].type === 'object') {
        payload[prop] = metadata;
      } else {
        payload[prop] = JSON.stringify(metadata);
      }

      /* istanbul ignore else */
      if (onUploadCallback) {
        tasks.push(onUploadCallback({
          payload,
          metadata,
          field: prop,
          schema: schema[prop],
          destFile: attachment.path,
        }));
      }
    }
  });

  attachments.inputs.forEach(key => {
    /* istanbul ignore else */
    if (typeof payload[key] === 'string' && payload[key].substr(0, 5) === 'data:') {
      const details = payload[key].match(RE_DATA)[1].split(';');
      const base64Data = payload[key].replace(RE_DATA, '');

      const fileName = details[1] ? details[1].split('name=')[1] : details[0].match(/\/(\w+)\b/)[1];
      const destFile = path.join(baseDir, attachments.uploadDir || 'uploads', `${Date.now()}_${fileName}`);

      // save file on disk before anything else!
      fs.outputFileSync(destFile, base64Data, 'base64');

      const _schema = Model.options.$schema.properties[key];
      const metadata = {
        filePath: path.relative(baseDir, destFile),
        fileName: fileName.replace(/^\/+/, ''),
        fileSize: fs.statSync(destFile).size,
        fileType: details[0],
      };

      if (Model.rawAttributes.filePath
        && Model.rawAttributes.fileName
        && Model.rawAttributes.fileSize
        && Model.rawAttributes.fileType
      ) {
        delete payload[key];
        Object.assign(payload, metadata);
        return;
      }

      if (_schema.type === 'object') {
        payload[key] = metadata;
      } else {
        payload[key] = JSON.stringify(metadata);
      }

      /* istanbul ignore else */
      if (onUploadCallback) {
        tasks.push(onUploadCallback({
          payload,
          metadata,
          destFile,
          field: key,
          schema: _schema,
        }));
      }
    }
  });

  return Promise.all(tasks);
}

// FIXME: too much complexity for updating related rows, just create new ones!!!
function _buildTasks(references, inputData, modelName, _options, models) {
  const tasks = {
    before: [],
    after: [],
  };

  if (_options.attachments) {
    tasks.before.push(() => _saveUploads(models[modelName], inputData, _options.attachments, _options.upload));
  }

  Object.keys(inputData).forEach(prop => {
    const assoc = models[modelName].associations && models[modelName].associations[prop];
    const ref = references[prop];

    /* istanbul ignore else */
    if (ref && assoc) {
      const through = ref.through && typeof ref.through.model === 'string' ? ref.through.model : ref.through;
      const fields = ref.references.primaryKeys.map(x => x.prop);

      const items = !Array.isArray(inputData[prop])
        ? [inputData[prop]]
        : inputData[prop];

      const _ref = models[ref.model];
      const _pk = _ref.primaryKeyAttribute;

      items.forEach(item => {
        if (_options.attachments) {
          tasks.before.push(() => _saveUploads(_ref, item, _options.attachments, _options.upload));
        }

        const _value = item[ref.model];
        const _isNew = _value && !Object.keys(_ref.primaryKeys).every(x => _value[x]);
        const _whereOpts = fields.reduce((prev, cur) => {
          if (item[cur]) {
            prev[cur] = item[cur];
          }

          delete item[cur];
          return prev;
        }, {});

        delete item[ref.model];

        tasks.after.push((fk, opts, isUpdate) => {
          const logging = opts.logging;

          const props = {
            [assoc.foreignKey]: fk,
          };

          /* istanbul ignore else */
          if (!isUpdate && _value && _value[_pk]) {
            item[through ? assoc.otherKey : assoc.foreignKey] = _value[_pk];
          }

          if (item[assoc.otherKey] && !_whereOpts[_ref.primaryKeyAttribute]) {
            _whereOpts[assoc.otherKey] = item[assoc.otherKey];

            delete item[assoc.otherKey];
          }

          /* istanbul ignore else */
          if (_isNew) {
            if (through) {
              return _ref.create(_value || {}, { logging }).then(x => {
                return models[through].create(Object.assign({
                  [assoc.otherKey]: x[_pk],
                }, item, props));
              }, { logging });
            }
          } else if (through) {
            if (!_whereOpts[models[through].primaryKeyAttribute]) {
              _whereOpts[assoc.foreignKey] = props[assoc.foreignKey];

              delete props[assoc.foreignKey];
            }

            /* istanbul ignore else */
            if (isUpdate) {
              return _options.noupdate !== true && models[through]
                .update(Object.assign(item, props), { where: _whereOpts, logging });
            }

            return models[through]
              .create(Object.assign(item, props, _whereOpts), { logging });
          } else if (isUpdate) {
            return _options.noupdate !== true && _ref
              .update(item, { where: Object.assign(props, _whereOpts), logging });
          }

          return _ref.create(Object.assign(item, props), { logging });
        });
      });
    }
  });

  return tasks;
}

function _mixOptions(source, target) {
  /* istanbul ignore else */
  if (source) {
    Object.keys(source).forEach(key => {
      if (!target[key]) {
        target[key] = source[key];
      } else {
        target[key] = _mixOptions(source[key], target[key] || {});
      }
    });
  }

  return target;
}

function _pushKeys(model, obj) {
  Object.keys(model.rawAttributes).forEach(key => {
    const prop = model.rawAttributes[key];

    /* istanbul ignore else */
    if ((prop.primaryKey || prop.references) && obj.attributes.indexOf(prop.fieldName) === -1) {
      obj.attributes.unshift(prop.fieldName);
    }
  });
}

function _packOptions(action, model, obj) {
  obj.attributes = (obj.attributes || []).slice();
  obj.include = (obj.include || []).slice();

  /* istanbul ignore else */
  if (action.indexOf('find') === 0) {
    _pushKeys(model, obj);
  }

  Object.keys(obj).forEach(key => {
    /* istanbul ignore else */
    if (!Array.isArray(obj[key]) && typeof obj[key] === 'object' && obj[key] !== null && model.associations[key]) {
      const target = model.associations[key].target;
      const props = _packOptions(action, target, obj[key] || {});

      /* istanbul ignore else */
      if (obj.where && obj.where[key]) {
        if (model.associations[key].through) {
          props.through = {
            attributes: Object.keys(obj.where[key]),
            model: model.associations[key].through.model,
            where: obj.where[key],
          };

          _pushKeys(model.associations[key].through.model, props.through);
        } else {
          props.where = obj.where[key];
        }

        delete obj.where[key];
      }

      /* istanbul ignore else */
      if (props.order && typeof props.order[0] === 'string') {
        props.order.unshift({
          model: target,
          as: key,
        });

        obj.order = obj.order || [];

        /* istanbul ignore else */
        if (obj.order[0] && typeof obj.order[0][0] !== 'object') {
          obj.order = [obj.order];
        }

        obj.order.push(props.order);

        delete props.order;
      }

      switch (action) {
        case 'findAll':
        case 'findOne':
          props.model = target;
          props.as = key;

          if (model.associations[key].through) {
            const refName = model.associations[key].through.model.name;
            const srcName = model.associations[key].target.name;

            if (props[refName]) {
              props.include = props.include.concat(props[refName][srcName].include);
              props.attributes = props.attributes.concat(props[refName][srcName].attributes);
            }

            delete props[refName];
          }

          obj.include.push(props);
          break;

        case 'destroy':
          obj.include.push(model.associations[key]);
          break;

        // nothing to do
        default: break;
      }

      delete obj[key];
    }
  });

  return obj;
}

function _getOpts(model, props, action, params) {
  const fields = Object.assign({}, model.options.$attributes || {});
  const attrs = fields[action]
    || fields.findAll
    || [];

  const obj = {
    include: [],
    attributes: [],
  };

  /* istanbul ignore else */
  if (fields.where) {
    params.where = Object.assign({}, params.where, fields.where);
  }

  /* istanbul ignore else */
  if (params.search) {
    const lookup = fields.search || fields.findAll;
    const orWhere = [];

    let query = params.search.replace(/[^^$\w]+/g, '%');

    query = `%${query}%`.replace(/^%\^/, '').replace(/\$%$/, '');

    // FIXME: nested lookup is not well-tested!
    lookup.forEach(key => {
      if (!key.includes('.')) {
        orWhere.push({ [key]: { [Op.like]: query } });
      } else {
        const [ref] = key.split('.');

        params.include = params.include || [];
        params.include.push({
          model: model.associations[ref].target,
          as: ref,
        });

        orWhere.push({ [`$${key}$`]: { [Op.like]: query } });
      }
    });

    delete params.search;
    params.where = params.where || {};
    params.where[Op.or] = orWhere;
  }

  attrs.forEach(field => {
    const key = typeof field === 'object'
      ? field.prop
      : field;

    /* istanbul ignore else */
    if (!key || props[field]) {
      return;
    }

    if (key.indexOf('.') === -1) {
      obj.attributes.push(key);
    } else {
      const keys = key.split('.');

      let u = obj;
      let k;

      while (keys.length > 1) {
        k = keys.shift();

        /* istanbul ignore else */
        if (!u[k]) {
          u[k] = {
            include: [],
            attributes: [],
          };
        }

        u = u[k];
      }

      u.attributes.push(keys[0]);
    }
  });

  return _packOptions(action, model, _mixOptions(params, obj));
}

module.exports = (conn, options, modelName) => {
  /* istanbul ignore else */
  if (typeof options === 'string') {
    modelName = options;
    options = null;
  }

  /* istanbul ignore else */
  if (!(conn && conn.$refs && typeof conn.$refs[modelName] === 'object')) {
    throw new Error(`Invalid model definition, given '${modelName}'`);
  }

  const model = conn.models[modelName];

  options = options || {};
  options.keys = options.keys || [];

  const _where = {};
  const _props = {};

  Object.keys(model.rawAttributes)
    .filter(x => model.rawAttributes[x].primaryKey).sort()
    .forEach((pk, i) => {
      /* istanbul ignore else */
      if (typeof options.keys[i] !== 'undefined') {
        _where[pk] = options.keys[i];
      }
    });

  /* istanbul ignore else */
  if (typeof options.where === 'string') {
    const p = options.where.split(';');

    p.forEach(v => {
      const s = v.split(':').filter(Boolean);

      _where[s[0]] = s.length === 2
        ? s[1]
        : s;
    });
  }

  const _schema = types.cleanSchema(model.options.$schema || {});

  function push(ref, nested) {
    const through = typeof ref.params.through === 'object'
      ? ref.params.through.model
      : ref.params.through;

    // attribute references
    _props[ref.params.as] = {
      through,
      model: ref.target,
      plural: _util.pluralize(ref.target),
      singular: _util.singularize(ref.target),
      references: conn.$refs[ref.target].$references,
      hasManyItems: ref.method.indexOf('Many') > 0,
      requiredProps: conn.$refs[ref.target].$schema.required || [],
    };

    /* istanbul ignore else */
    if (nested > 0) {
      _props[ref.params.as].uiSchema = conn.$refs[ref.target].$uiSchema || {};
    }
  }

  function append(id, nested) {
    /* istanbul ignore else */
    if (!(conn.$refs[id].$references && conn.$refs[id].$dependencies)) {
      return;
    }

    const fields = conn.$refs[id].$schema.properties;

    Object.keys(conn.$refs[id].$dependencies).forEach(dep => {
      const ref = conn.$refs[id].$dependencies[dep];

      push(ref, nested);

      /* istanbul ignore else */
      if (!nested) {
        return;
      }

      // append references from virtual-models
      Object.keys(fields).forEach(prop => {
        const _ref = (fields[prop].items || fields[prop]).$ref;

        /* istanbul ignore else */
        if (conn.$refs[_ref]) {
          _props[_ref] = conn.$refs[_ref].$schema;

          append(_ref, conn.$refs[id].$schema.virtual ? 0 : (nested - 1));
        }
      });
    });
  }

  // model references
  _props[modelName] = Object.assign({
    model: modelName,
  }, model.options.name);

  _props[modelName].references = conn.$refs[modelName].$references;

  append(modelName, 1);

  // shared resource
  const instance = {
    options: {
      model: modelName,
      refs: conn.schemas.reduce((prev, cur) => {
        if (!prev[cur.id]) {
          prev[cur.id] = cur;
        }

        return prev;
      }, _props),
      schema: _schema,
      uiSchema: model.options.$uiSchema || {},
      attributes: model.options.$attributes || {},
    },
  };

  function ok(result) {
    /* istanbul ignore else */
    if (typeof result !== 'undefined' && result !== null) {
      const data = _expandData(!options.raw, result, options.attachments || []);

      if (Array.isArray(data)) {
        data.forEach(x => _fixRefs(_props, x));
      } else {
        _fixRefs(_props, data);
      }
      return data;
    }
  }

  function err(error) {
    if (options.fallthrough) {
      instance.options.failure = error.message;
    } else {
      throw error;
    }
  }

  function build(payload, isUpdate, _options) {
    _options = _options || {};
    _options.logging = options.logging || _options.logging;
    _options.where = Object.assign({}, options.where, _options.where, _where);

    const _payload = _cleanData(payload || options.payload, model);
    const _tasks = _buildTasks(_props, _payload, model.name, options, conn.models);
    const _opts = _getOpts(model, _props, isUpdate ? 'update' : 'create', _options);

    return Promise.resolve()
      .then(() => _tasks.before.reduce((prev, cur) => prev.then(() => cur(_opts, isUpdate)), Promise.resolve()))
      .then(() => model[isUpdate ? 'update' : 'create'](_payload, _opts))
      .then(row => {
        let pk = !isUpdate
          ? row[0]
          : null;

        if (!Array.isArray(row)) {
          pk = row[model.primaryKeyAttribute];
        }

        if (!pk && _opts.where) {
          pk = _opts.where[model.primaryKeyAttribute];
        }

        _payload[model.primaryKeyAttribute] = _payload[model.primaryKeyAttribute] || pk;

        return _tasks.after.reduce((prev, cur) => prev.then(() => cur(pk, _opts, isUpdate)), Promise.resolve());
      })
      .then(() => _payload)
      .catch(err);
  }

  function fetch(method, _options) {
    _options = _options || {};
    _options.logging = options.logging || _options.logging;
    _options.where = Object.assign({}, options.where, _options.where, _where);

    const _pk = model.primaryKeyAttribute;
    const _opts = _getOpts(model, _props, method, _options);
    const _names = _opts.include.map(inc => inc.as);

    // see: https://github.com/sequelize/sequelize/pull/9384
    _opts.raw = true;
    _opts.plain = false;

    return Promise.resolve()
      .then(() => model[method](_opts))
      .then(data => {
        if (method.indexOf('find') === 0) {
          const result = _unflattenObj(_pk, _names, data, instance.options.refs);

          return method === 'findOne' ? result[0] : result;
        }

        return data;
      })
      .then(ok)
      .catch(err);
  }

  instance.actions = {
    update: (payload, _options) => build(payload, true, _options),
    findAll: _options => fetch('findAll', _options),
    findOne: _options => fetch('findOne', _options),
    destroy: _options => fetch('destroy', _options),
    count: _options => fetch('count', _options),
    create: (payload, _options) => build(payload, false, _options),
  };

  return instance;
};
