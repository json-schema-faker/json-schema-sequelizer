'use strict';

const _util = require('sequelize').Utils;
const Op = require('sequelize').Op;

const fs = require('fs-extra');
const path = require('path');
const types = require('./types');

const RE_DATA = /^data:(.+?);base64,/;

function _cleanData(values, model) {
  Object.keys(model.rawAttributes).forEach(key => {
    const prop = model.rawAttributes[key];

    /* istanbul ignore else */
    if ((prop.primaryKey && !values[key]) || (prop._autoGenerated && !prop.references) || (prop.references && !values[key])) {
      delete values[key];
    }

    /* istanbul ignore else */
    if (prop.references) {
      const { Model, fieldName } = prop.type.options;

      /* istanbul ignore else */
      if (values[Model.name] && values[Model.name][fieldName]) {
        values[key] = values[Model.name][fieldName];
      }
    }
  });

  Object.keys(model.associations).forEach(key => {
    const assoc = model.associations[key];
    const target = (assoc.through && assoc.through.model) || assoc.target;

    /* istanbul ignore else */
    if (Array.isArray(values[key])) {
      values[key] = values[key].map(x => _cleanData(x, target));
    } else if (values[key]) {
      values[key] = _cleanData(values[key], target);
    }
  });

  return values;
}

// Sequelize is yielding `row.null` for some reason!
function _fixPkNull(row, model) {
  /* istanbul ignore else */
  if (row[model.primaryKeyAttribute] === null && row.null > 0) {
    row.dataValues[model.primaryKeyAttribute] = row.null;
    delete row.null;
  }
  return row;
}

function _isData(value) {
  return typeof value === 'string' && RE_DATA.test(value);
}

function _fixRefs(refs, values) {
  Object.keys(refs).forEach(ref => {
    /* istanbul ignore else */
    if (Array.isArray(values[ref]) && refs[ref] && refs[ref].through) {
      const through = typeof refs[ref].through === 'object'
        ? refs[ref].through.model
        : refs[ref].through;

      values[ref] = values[ref].map(item => {
        const sub = item[through];

        delete item[through];
        sub[refs[ref].model] = item;
        return sub;
      });
    }
  });
}

function _fileInfo(baseDir, data, obj) {
  /* istanbul ignore else */
  if (!data) {
    throw new Error('File data is missing');
  }

  /* istanbul ignore else */
  if (Array.isArray(data)) {
    return data.map(x => _fileInfo(baseDir, x, obj));
  }

  delete obj.$upload;
  return {
    mtime: (data.lastModifiedDate || new Date()).toGMTString(),
    path: path.relative(baseDir, data.path || data.filepath),
    name: data.name || data.originalFilename,
    type: data.type || data.mimetype,
    size: data.size,
    ...obj,
  };
}

function _pushUpload(payload, metadata, destFile, onUploadCallback) {
  if (Array.isArray(metadata)) {
    return Promise.all(metadata.map(item => {
      /* istanbul ignore else */
      if (onUploadCallback) {
        return onUploadCallback({
          payload,
          destFile,
          metadata: item,
        });
      }
      return { ...item, ...payload };
    }));
  }

  Object.assign(payload, metadata);

  /* istanbul ignore else */
  if (onUploadCallback) {
    return onUploadCallback({
      payload,
      metadata,
      destFile,
    });
  }
  return payload;
}

async function _saveBase64(payload, attachments, onUploadCallback) {
  const baseDir = attachments.baseDir || process.cwd();
  const details = payload.$upload.match(RE_DATA)[1].split(';');
  const base64Data = payload.$upload.replace(RE_DATA, '');

  const fileName = details[1] ? `_${details[1].split('name=')[1]}` : `_${details[0].replace(/\W+/g, '.')}`;
  const destFile = path.join(baseDir, attachments.uploadDir || 'uploads', `${Date.now()}${fileName}`);

  // save file on disk before anything else!
  fs.outputFileSync(destFile, base64Data, 'base64');

  const metadata = {
    mtime: new Date(),
    path: path.relative(baseDir, destFile),
    name: path.basename(destFile),
    size: fs.statSync(destFile).size,
    type: details[0],
  };

  delete payload.$upload;
  return _pushUpload(payload, metadata, destFile, onUploadCallback);
}

async function _saveUpload(payload, attachments, onUploadCallback) {
  const baseDir = attachments.baseDir || process.cwd();
  const input = _fileInfo(baseDir, attachments.files[payload.$upload], payload);

  return _pushUpload(payload, input, input.path || input.filepath, onUploadCallback);
}

function _fixedURL(params) {
  const parts = ['url:'];

  /* istanbul ignore else */
  if (params.type) parts.push(params.type, ';');
  /* istanbul ignore else */
  if (params.size) parts.push(params.size, ',');
  /* istanbul ignore else */
  if (params.name) parts.push(params.name, '@');

  return parts.concat(params.path).join('');
}

function _walkInput(data, model, models, references, walkCallback) {
  // eslint-disable-next-line wrap-iife
  (function walk(obj, ref, prop, parent, schema, keypath) {
    /* istanbul ignore else */
    if (!obj || typeof obj !== 'object') return obj;

    /* istanbul ignore else */
    if (Array.isArray(obj)) {
      return obj.forEach((x, i) => walk(x, ref, i, obj, schema.items, keypath.concat(i)));
    }

    if (ref && obj[ref.through]) {
      const next = obj[ref.through];

      delete obj[ref.through];
      next[ref.model] = obj;
      parent[prop] = next;
      return;
    }

    /* istanbul ignore else */
    if (!walkCallback(null, prop, obj, parent, schema, keypath)) {
      Object.keys(obj).forEach(key => {
        let _schema = schema.properties[key];
        /* istanbul ignore else */
        if (!walkCallback(key, prop, obj[key], obj, _schema, keypath.concat(key))) {
          const info = references[key];

          /* istanbul ignore else */
          if (info && info.through) {
            _schema = info.hasManyItems
              ? { items: models[info.through].options.$schema }
              : models[info.through].options.$schema;
          }
          walk(obj[key], info, key, obj, _schema, keypath.concat(key));
        }
      });
    }
    return obj;
  })(data, null, null, null, models[model].options.$schema, []);
}

function _handleFailure(e, name, keypath, association) {
  const suffix = association ? ` (${association})` : '';

  if (!keypath) {
    throw new Error(`${e.message} while calling ${name}${suffix}`, { cause: e });
  } else if (!name) {
    throw new Error(`${e.message}\n  on ${keypath.join('.')}${suffix}`, { cause: e });
  } else {
    throw new Error(`${e.message}\n  on ${name}.${keypath.join('.')}${suffix}`, { cause: e });
  }
}

function _buildTasks(references, inputData, modelName, _options, models) {
  const tasks = {
    before: [],
    after: [],
    refs: [],
  };

  _walkInput(inputData, modelName, models, references, (key, prop, value, parent, schema, keypath) => {
    /* istanbul ignore else */
    if (!value) return true;
    /* istanbul ignore else */
    if (key === null) tasks.refs.push(value);
    /* istanbul ignore else */
    if (_isData(value.$upload)) {
      tasks.before.unshift(() => _saveBase64(value, _options.attachments, _options.upload)
        .then(result => {
          parent[key] = schema && schema.type === 'string' ? _fixedURL(result) : result;
        }).catch(e => _handleFailure(e, modelName, keypath)));
      return true;
    }
    /* istanbul ignore else */
    if (value.$upload) {
      tasks.before.unshift(() => _saveUpload(value, _options.attachments, _options.upload)
        .then(result => {
          if (schema && schema.type === 'string') {
            parent[key] = _fixedURL(result);
          } else if (Array.isArray(parent)) {
            parent.splice(prop, 1, ...[].concat(result));
          } else {
            parent[key] = result;
          }
        }).catch(e => _handleFailure(e, modelName, keypath)));
      return true;
    }
  });

  tasks.after.push(async (fk, opts, cursor, isUpdate) => {
    const defaults = { logging: opts.logging, transaction: opts.transaction };

    function update(model, input, where, key, pk) {
      return model.update({ ...input, [key]: undefined }, { ...defaults, where: { ...where, [key]: pk } });
    }

    async function upsert(key, model, source, context, keypath = []) {
      const props = Object.keys(context);
      const refs = model.associations;

      for (const field of props) {
        try {
          /* istanbul ignore else */
          if (refs[field] && context[field]) {
            const input = context[field];
            const {
              target, through, associationType, targetKey, foreignKey, foreignIdentifier,
            } = refs[field];

            /* istanbul ignore else */
            if (associationType === 'BelongsToMany') {
              for (let i = 0; i < input.length; i += 1) {
                const item = input[i];

                try {
                  const other = (through && through.model) || model;

                  /* istanbul ignore else */
                  if (tasks.refs.length > 0) {
                    await upsert(key, target, null, tasks.refs.shift(), keypath.concat([field, i]));
                  }

                  /* istanbul ignore else */
                  if (through) {
                    await upsert(key, other, other.name, item, keypath.concat([field, i]));
                  }

                  if (isUpdate && (item[targetKey] || item[foreignIdentifier])) {
                    const where = {
                      [foreignKey]: key,
                    };

                    /* istanbul ignore else */
                    if (item[targetKey]) {
                      where[targetKey] = item[targetKey];
                    } else if (item[foreignIdentifier]) {
                      where[foreignIdentifier] = item[foreignIdentifier];
                    }

                    delete item[targetKey];
                    const [row, created] = await other.findOrCreate({ ...defaults, where, defaults: item });
                    if (!created) await row.update(item);
                  } else {
                    item[foreignKey] = key;
                    const row = await other.create(item, defaults);
                    item[targetKey] = _fixPkNull(row, other)[targetKey];
                  }
                } catch (e) {
                  _handleFailure(e, null, keypath.concat([field, i]), associationType);
                }
              }
            }

            /* istanbul ignore else */
            if (associationType === 'BelongsTo') {
              let pk;
              if (input[targetKey]) {
                await update(target, input, null, targetKey, pk = input[targetKey]);
              } else {
                const row = await target.create(input, defaults);
                pk = input[targetKey] = _fixPkNull(row, target)[targetKey];
              }

              /* istanbul ignore else */
              if (cursor && cursor.rawAttributes[foreignKey]) {
                await cursor.update({ [foreignKey]: pk });
              }

              context[foreignKey] = pk;
              delete context[field];

              /* istanbul ignore else */
              if (tasks.refs.length > 0) {
                await upsert(pk, target, null, tasks.refs.shift(), keypath.concat(field));
              }
            }

            /* istanbul ignore else */
            if (associationType === 'HasMany') {
              const pk = target.primaryKeyAttribute;

              for (let i = 0; i < input.length; i += 1) {
                const item = input[i];

                try {
                  if (isUpdate && item[pk]) {
                    await update(target, item, null, pk, item[pk]);
                  } else {
                    item[foreignKey] = key;
                    await target.create(item, defaults);
                  }
                } catch (e) {
                  _handleFailure(e, null, keypath.concat([field, i]), associationType);
                }
              }
            }

            /* istanbul ignore else */
            if (associationType === 'HasOne') {
              const pk = target.primaryKeyAttribute;

              let row = input;
              if (Array.isArray(input)) {
                row = context[field] = input[0];
              }

              if (isUpdate && row[pk]) {
                await update(target, row, null, pk, row[pk]);
              } else {
                context[foreignKey] = row[foreignKey] = key;
                await target.create(row, defaults);
              }
            }
          }
        } catch (e) {
          const target = !keypath.length ? `${model.name}${key ? `(${key})` : ''}` : null;
          const through = keypath.length > 0 && source ? `${field}<${source}>` : field;

          _handleFailure(e, target, keypath.concat(through));
        }
      }
    }

    try {
      await upsert(fk, models[modelName], null, tasks.refs.shift());
    } catch (e) {
      _handleFailure(e, `${modelName}#${isUpdate ? 'update' : 'create'}`);
    }
  });

  return tasks;
}

function _mixOptions(source, target) {
  /* istanbul ignore else */
  if (source) {
    Object.keys(source).forEach(key => {
      if (!target[key]) {
        target[key] = source[key];
      } else if (!['include', 'transaction'].includes(key)) {
        target[key] = _mixOptions(source[key], target[key] || {});
      }
    });
  }

  return target;
}

function _pushKeys(model, obj) {
  Object.keys(model.rawAttributes).forEach(key => {
    const prop = model.rawAttributes[key];

    /* istanbul ignore else */
    if ((prop.primaryKey || prop.references) && obj.attributes.indexOf(prop.fieldName) === -1) {
      obj.attributes.unshift(prop.fieldName);
    }
  });
}

function _packOptions(action, model, obj) {
  obj.attributes = (obj.attributes || []).slice();
  obj.include = (obj.include || []).slice();

  /* istanbul ignore else */
  if (action.indexOf('find') === 0) {
    _pushKeys(model, obj);
  }

  Object.keys(obj).forEach(key => {
    /* istanbul ignore else */
    if (!Array.isArray(obj[key]) && typeof obj[key] === 'object' && obj[key] !== null && model.associations[key]) {
      const target = model.associations[key].target;
      const props = _packOptions(action, target, obj[key] || {});

      /* istanbul ignore else */
      if (obj.where && obj.where[key]) {
        if (model.associations[key].through) {
          props.through = {
            attributes: Object.keys(obj.where[key]),
            model: model.associations[key].through.model,
            where: obj.where[key],
          };

          _pushKeys(model.associations[key].through.model, props.through);
        } else {
          props.where = obj.where[key];
        }

        delete obj.where[key];
      }

      /* istanbul ignore else */
      if (props.order && typeof props.order[0] === 'string') {
        props.order.unshift({
          model: target,
          as: key,
        });

        obj.order = obj.order || [];

        /* istanbul ignore else */
        if (obj.order[0] && typeof obj.order[0][0] !== 'object') {
          obj.order = [obj.order];
        }

        obj.order.push(props.order);

        delete props.order;
      }

      switch (action) {
        case 'findAll':
        case 'findOne':
          props.model = target;
          props.as = key;

          /* istanbul ignore else */
          if (model.associations[key].through) {
            const refName = model.associations[key].through.model.name;
            const srcName = model.associations[key].target.name;

            /* istanbul ignore else */
            if (props[refName]) {
              props.include = props.include.concat(props[refName][srcName].include);
              props.attributes = props.attributes.concat(props[refName][srcName].attributes);
            }

            delete props[refName];
          }

          obj.include.push(props);
          break;

        case 'destroy':
          obj.include.push(model.associations[key]);
          break;

        // nothing to do
        default: break;
      }

      delete obj[key];
    }
  });

  return obj;
}

function _getOpts(model, props, action, options) {
  const fields = Object.assign({}, model.options.$attributes || {});
  const attrs = fields[action] || (action !== 'count' ? fields.findAll : null) || [];

  const obj = {
    include: [],
    attributes: [],
  };

  /* istanbul ignore else */
  if (fields.where) {
    options.where = Object.assign({}, options.where, fields.where);
  }

  /* istanbul ignore else */
  if (options.search) {
    const lookup = fields.search || fields.findAll;
    const orWhere = [];

    let query = options.search.replace(/[^^$\w]+/g, '%');

    query = `%${query}%`.replace(/^%\^/, '').replace(/\$%$/, '');

    lookup.forEach(key => {
      if (!key.includes('.')) {
        orWhere.push({ [key]: { [Op.like]: query } });
      } else {
        const [ref] = key.split('.');

        options.include = options.include || [];
        options.include.push({
          model: model.associations[ref].target,
          as: ref,
        });

        orWhere.push({ [`$${key}$`]: { [Op.like]: query } });
      }
    });

    delete options.search;
    options.where = options.where || {};
    options.where[Op.or] = orWhere;
  }

  attrs.forEach(field => {
    const key = typeof field === 'object'
      ? field.prop
      : field;

    /* istanbul ignore else */
    if (!key || props[key]) {
      return;
    }

    if (key.indexOf('.') === -1) {
      obj.attributes.push(key);
    } else {
      const keys = key.split('.');

      let u = obj;
      let k;

      while (keys.length > 1) {
        k = keys.shift();

        /* istanbul ignore else */
        if (!u[k]) {
          u[k] = {
            include: [],
            attributes: [],
          };
        }

        u = u[k];
      }

      u.attributes.push(keys[0]);
    }
  });

  return _packOptions(action, model, _mixOptions(options, obj));
}

module.exports = (conn, options, modelName) => {
  /* istanbul ignore else */
  if (typeof options === 'string') {
    modelName = options;
    options = null;
  }

  /* istanbul ignore else */
  if (!(conn && conn.$refs && typeof conn.$refs[modelName] === 'object')) {
    throw new Error(`Invalid model definition, given '${modelName}'`);
  }

  const model = conn.models[modelName];

  options = options || {};
  options.keys = options.keys || [];

  const _where = {};
  const _props = {};

  Object.keys(model.rawAttributes)
    .filter(x => model.rawAttributes[x].primaryKey).sort()
    .forEach((pk, i) => {
      /* istanbul ignore else */
      if (typeof options.keys[i] !== 'undefined') {
        _where[pk] = options.keys[i];
      }
    });

  /* istanbul ignore else */
  if (typeof options.where === 'string') {
    const p = options.where.split(';');

    p.forEach(v => {
      const s = v.split(':').filter(Boolean);

      _where[s[0]] = s.length === 2
        ? s[1]
        : s;
    });
  }

  const _schema = types.cleanSchema(model.options.$schema || {});

  function push(ref, nested) {
    const through = typeof ref.params.through === 'object'
      ? ref.params.through.model
      : ref.params.through;

    // attribute references
    _props[ref.params.as] = {
      through,
      model: ref.target,
      plural: _util.pluralize(ref.target),
      singular: _util.singularize(ref.target),
      references: conn.$refs[ref.target].$references,
      hasManyItems: ref.method.indexOf('Many') > 0,
      requiredProps: conn.$refs[ref.target].$schema.required || [],
    };

    /* istanbul ignore else */
    if (nested > 0) {
      _props[ref.params.as].uiSchema = conn.$refs[ref.target].$uiSchema || {};
    }
  }

  function append(id, nested) {
    /* istanbul ignore else */
    if (!(conn.$refs[id].$references && conn.$refs[id].$dependencies)) {
      return;
    }

    const fields = conn.$refs[id].$schema.properties;

    Object.keys(conn.$refs[id].$dependencies).forEach(dep => {
      const ref = conn.$refs[id].$dependencies[dep];

      push(ref, nested);

      /* istanbul ignore else */
      if (!nested) {
        return;
      }

      // append references from virtual-models
      Object.keys(fields).forEach(prop => {
        const _ref = (fields[prop].items || fields[prop]).$ref;

        /* istanbul ignore else */
        if (conn.$refs[_ref]) {
          _props[_ref] = conn.$refs[_ref].$schema;

          append(_ref, conn.$refs[id].$schema.virtual ? 0 : (nested - 1));
        }
      });
    });
  }

  // model references
  _props[modelName] = Object.assign({
    model: modelName,
  }, model.options.name);

  _props[modelName].references = conn.$refs[modelName].$references;

  append(modelName, 1);

  // shared resource
  const instance = {
    options: {
      model: modelName,
      refs: conn.schemas.reduce((prev, cur) => {
        if (!prev[cur.id]) {
          prev[cur.id] = cur;
        }

        return prev;
      }, _props),
      schema: _schema,
      uiSchema: model.options.$uiSchema || {},
      attributes: model.options.$attributes || {},
    },
  };

  function ok(result) {
    /* istanbul ignore else */
    if (typeof result !== 'undefined' && result !== null) {
      if (Array.isArray(result)) {
        result.forEach(x => _fixRefs(_props, x));
      } else {
        _fixRefs(_props, result);
      }
      return result;
    }
  }

  function err(error) {
    if (options.fallthrough) {
      instance.options.failure = error.message;
    } else {
      throw error;
    }
  }

  function build(payload, isUpdate, _options) {
    _options = _options || {};
    _options.logging = options.logging || _options.logging;
    _options.reload = options.reload || _options.reload;
    _options.where = Object.assign({}, _options.where, _where);

    const _pk = model.primaryKeyAttribute;

    let _payload;
    let _tasks;
    let _opts;
    return Promise.resolve()
      .then(() => {
        _payload = _cleanData({ ...(payload || options.payload) }, model);
        _tasks = _buildTasks(_props, _payload, model.name, options, conn.models);
        _opts = _getOpts(model, _props, isUpdate ? 'update' : 'create', _options);

        delete _payload[_pk];
      })
      .then(() => _tasks.before.reduce((prev, cur) => prev.then(() => cur(_opts, isUpdate)), Promise.resolve()))
      .then(() => model[isUpdate ? 'update' : 'create'](_payload, _opts))
      .then(row => {
        let pk;
        /* istanbul ignore else */
        if (!Array.isArray(row)) {
          pk = _fixPkNull(row, model)[_pk];
        }

        /* istanbul ignore else */
        if (!pk && _opts.where) {
          pk = _opts.where[_pk];
        }

        _payload[_pk] = _payload[_pk] || pk;

        return Promise.resolve()
          .then(() => (!isUpdate ? [row, _payload] : row))
          .then(result => _tasks.after.reduce((prev, cur) => prev
            .then(() => cur(pk, _opts, !isUpdate ? result[0] : null, isUpdate)), Promise.resolve())
            .then(() => {
              /* istanbul ignore else */
              if (_opts.reload) {
                _opts = _getOpts(model, _props, 'findOne', _options);
                _opts.where[_pk] = pk;

                return model.findOne(_opts).then(x => (!isUpdate ? [x, _payload] : x));
              }
              return result;
            }));
      })
      .catch(err);
  }

  function fetch(method, _options) {
    _options = _options || {};
    _options.logging = options.logging || _options.logging;
    _options.where = Object.assign({}, _options.where, _where);

    const _opts = _getOpts(model, _props, method, _options);

    return Promise.resolve()
      .then(() => model[method](_opts))
      .then(ok)
      .catch(err);
  }

  instance.actions = {
    update: (payload, _options) => build(payload, true, _options),
    findAll: _options => fetch('findAll', _options),
    findOne: _options => fetch('findOne', _options),
    destroy: _options => fetch('destroy', _options),
    count: _options => fetch('count', _options),
    create: (payload, _options) => build(payload, false, _options),
  };

  return instance;
};
